\FloatBarrier
\subsection{Amortized Cost of Dynamic Arrays}

\pgfplotstableread{dat/w4/w4_pushback_amortized.dat}{\pushbackdata}

\begin{table}[htbp]
\centering
\caption{Execution time for \texttt{push\_back} with and without pre-allocation.}
\label{tab:pushback}
\begin{tabular}{rrrr}
\toprule
$n$ & With \texttt{reserve()} ($\mu$s) & Without \texttt{reserve()} ($\mu$s) & Ratio \\
\midrule
1\,000 & 0.48 & 0.78 & 1.63 \\
10\,000 & 5.03 & 7.12 & 1.42 \\
100\,000 & 55.2 & 67.7 & 1.23 \\
1\,000\,000 & 1\,118 & 2\,149 & 1.92 \\
\bottomrule
\end{tabular}
\end{table}

\Cref{tab:pushback} presents the execution time for inserting $n$ elements into a \texttt{std::vector} using \texttt{push\_back}, comparing pre-allocated vectors (via \texttt{reserve()}) against dynamically growing vectors. The ratio between the two approaches ranges from 1.2$\times$ to 1.76$\times$, confirming that amortized $O(1)$ insertion holds empirically: execution time scales linearly with $n$ in both cases.

The modest overhead without pre-allocation (averaging 1.5$\times$) validates the doubling strategy's efficiency. Occasional reallocations, though individually costly, contribute negligibly to total runtime when amortized across all insertions.
