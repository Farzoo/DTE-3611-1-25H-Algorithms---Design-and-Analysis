\section{Introduction}

Algorithm analysis is fundamental to computer science, providing theoretical foundations for efficient problem-solving~\cite{book:clrs:2009}. This study examines five algorithm families: sorting, string matching, graph traversal, shortest path computation, and dynamic programming for combinatorial optimisation. Additionally, we present a case study of network flow algorithms, comparing the Edmonds-Karp maximum flow method with a cycle-canceling minimum-cost maximum flow algorithm on randomly generated layered networks.

Our implementations leverage the Boost Graph Library~\cite{online:bgl:2025} for graph representations, while the STL~\cite{book:plauger:2000} provides reference implementations. The objective is twofold: to validate theoretical complexity bounds through empirical measurement, and to identify which variants perform best under various conditions.

A central concern in algorithm design is the classification of problems according to their inherent difficulty~\cite{course:dte3611:2025}. The complexity class $\mathbf{P}$ contains decision problems solvable in polynomial time, while $\mathbf{NP}$ comprises problems whose positive instances admit certificates verifiable in polynomial time. A problem is $\mathbf{NP}$-complete if it belongs to $\mathbf{NP}$ and every problem in $\mathbf{NP}$ reduces to it in polynomial time; it is $\mathbf{NP}$-hard if it is at least as difficult as any $\mathbf{NP}$-complete problem~\cite{article:cook:1971}. Under the widely-believed conjecture $\mathbf{P} \neq \mathbf{NP}$, no polynomial-time algorithm exists for NP-complete problems. However, dynamic programming often yields pseudo-polynomial solutions whose running time depends polynomially on numeric parameters rather than input size~\cite{article:bellman:1954}. This study investigates such solutions for the subset-sum and 0/1 knapsack problems.
